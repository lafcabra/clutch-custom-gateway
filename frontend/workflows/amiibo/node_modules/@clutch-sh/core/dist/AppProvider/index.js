import React from "react";
import { BrowserRouter as Router, Outlet, Route, Routes } from "react-router-dom";
import _ from "lodash";
import AppLayout from "../AppLayout";
import { ApplicationContext, ShortLinkContext } from "../Contexts";
import { Toast } from "../Feedback";
import { FEATURE_FLAG_POLL_RATE, featureFlags } from "../flags";
import Landing from "../landing";
import NotFound from "../not-found";
import { registeredWorkflows } from "./registrar";
import ShortLinkProxy, { ShortLinkBaseRoute } from "./short-link-proxy";
import ShortLinkStateHydrator from "./short-link-state-hydrator";
import { Theme } from "./themes";
import ErrorBoundary from "./workflow";
/**
 * Filter workflow routes using available feature flags.
 * @param workflows a list of valid Workflow objects.
 */
const featureFlagFilter = (workflows) => {
    return featureFlags().then(flags => workflows.filter(workflow => {
        /* eslint-disable-next-line no-param-reassign */
        workflow.routes = workflow.routes.filter(route => {
            const show = route.featureFlag === undefined ||
                ((flags === null || flags === void 0 ? void 0 : flags[route.featureFlag]) !== undefined &&
                    flags[route.featureFlag].booleanValue === true);
            return show;
        });
        return workflow.routes.length !== 0;
    }));
};
const ClutchApp = ({ availableWorkflows, configuration: userConfiguration, }) => {
    var _a;
    const [workflows, setWorkflows] = React.useState([]);
    const [isLoading, setIsLoading] = React.useState(true);
    const [workflowSessionStore, setWorkflowSessionStore] = React.useState();
    const [hydrateState, setHydrateState] = React.useState(null);
    const [hydrateError, setHydrateError] = React.useState(null);
    /** Used to control a race condition from displaying the workflow and the state being updated with the hydrated data */
    const [shortLinkLoading, setShortLinkLoading] = React.useState(false);
    const loadWorkflows = () => {
        registeredWorkflows(availableWorkflows, userConfiguration, [featureFlagFilter]).then(w => {
            setWorkflows(w);
            setIsLoading(false);
        });
    };
    React.useEffect(() => {
        loadWorkflows();
        const interval = setInterval(loadWorkflows, FEATURE_FLAG_POLL_RATE);
        return () => clearInterval(interval);
    }, []);
    const [discoverableWorkflows, setDiscoverableWorkflows] = React.useState([]);
    React.useEffect(() => {
        /** Filter out all of the workflows that are configured to be `hideNav: true`.
         * This prevents the workflows from being discoverable by the user from the UI,
         * both search and drawer navigation.
         *
         * The routes for all configured workflows will still be reachable
         * by manually providing the full path in the URI.
         */
        const pw = _.cloneDeep(workflows).filter(workflow => {
            const publicRoutes = workflow.routes.filter(route => {
                return !((route === null || route === void 0 ? void 0 : route.hideNav) !== undefined ? route.hideNav : false);
            });
            workflow.routes = publicRoutes; /* eslint-disable-line no-param-reassign */
            return publicRoutes.length !== 0;
        });
        setDiscoverableWorkflows(pw);
    }, [workflows]);
    const shortLinkProviderProps = {
        removeWorkflowSession: () => setWorkflowSessionStore(null),
        retrieveWorkflowSession: () => workflowSessionStore,
        storeWorkflowSession: setWorkflowSessionStore,
    };
    return (React.createElement(Router, null,
        React.createElement(Theme, { variant: "light" },
            React.createElement("div", { id: "App" },
                React.createElement(ApplicationContext.Provider, { value: { workflows: discoverableWorkflows } },
                    React.createElement(ShortLinkContext.Provider, { value: shortLinkProviderProps },
                        hydrateError && (React.createElement(Toast, { onClose: () => setHydrateError(null) },
                            "Unable to retrieve short link: ", (_a = hydrateError === null || hydrateError === void 0 ? void 0 : hydrateError.status) === null || _a === void 0 ? void 0 :
                            _a.text)),
                        React.createElement(Routes, null,
                            React.createElement(Route, { path: "/", element: React.createElement(AppLayout, { isLoading: isLoading }) },
                                React.createElement(Route, { key: "landing", path: "", element: React.createElement(Landing, null) }),
                                workflows.map((workflow) => {
                                    const workflowPath = workflow.path.replace(/^\/+/, "").replace(/\/+$/, "");
                                    const workflowKey = workflow.path.split("/")[0];
                                    return (React.createElement(Route, { path: `${workflowPath}/`, key: workflowKey, element: React.createElement(ErrorBoundary, { workflow: workflow },
                                            React.createElement(ShortLinkStateHydrator, { sharedState: hydrateState, clearTemporaryState: () => setHydrateState(null) }, !shortLinkLoading && React.createElement(Outlet, null))) },
                                        workflow.routes.map(route => {
                                            const heading = route.displayName
                                                ? `${workflow.displayName}: ${route.displayName}`
                                                : workflow.displayName;
                                            return (React.createElement(Route, { key: workflow.path, path: `${route.path.replace(/^\/+/, "").replace(/\/+$/, "")}`, element: React.cloneElement(React.createElement(route.component, null), {
                                                    ...route.componentProps,
                                                    heading,
                                                }) }));
                                        }),
                                        React.createElement(Route, { key: `${workflow.path}/notFound`, path: "*", element: React.createElement(NotFound, null) })));
                                }),
                                React.createElement(Route, { key: "short-links", path: `/${ShortLinkBaseRoute}/:hash`, element: React.createElement(ShortLinkProxy, { setLoading: setShortLinkLoading, hydrate: setHydrateState, onError: setHydrateError }) }),
                                React.createElement(Route, { key: "notFound", path: "*", element: React.createElement(NotFound, null) })))))))));
};
export default ClutchApp;
