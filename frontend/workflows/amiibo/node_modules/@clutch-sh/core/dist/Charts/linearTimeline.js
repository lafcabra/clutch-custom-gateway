import React from "react";
import { CartesianGrid, Legend, ResponsiveContainer, Scatter, ScatterChart, Tooltip, XAxis, YAxis, } from "recharts";
import { calculateDomainEdges, calculateTicks, localTimeFormatter } from "./helpers";
/**
 * We wrap the ScatterPlot Recharts component for use in linear timeline views. This is more useful than the
 * wrapper for linecharts for this specific use case of having "lanes" of events and their timestamps.
 */
// TODO(smonero): add tests for this component
const LinearTimeline = ({ data, xAxisDataKey = "timestamp", regularIntervalTicks = true, tickFormatterFunc = localTimeFormatter, legend = true, 
// Note that we don't set the default tooltipFormatter here because we pass the styling vals into the default
tooltipFormatterFunc = null, stylingProps = {}, }) => {
    var _a, _b;
    const combinedData = Object.keys(data).reduce((acc, lane) => {
        return [...acc, ...data[lane].points];
    }, []);
    const [xAxisDomainMin, xAxisDomainMax] = calculateDomainEdges(combinedData, xAxisDataKey, 0.2);
    let ticks = [];
    // If we want regularly spaced interval ticks along the X-Axis, we need to calculate the ticks ourselves,
    // rather than letting Recharts calculate them for us. We calculate them using the distance between the
    // max and min of the timestamps.
    if (regularIntervalTicks) {
        ticks = calculateTicks(combinedData, xAxisDataKey);
    }
    // Because we can't rely on using "category" for the Y-Axis, we need to assign Ids (based off the index)
    const mappingOfLaneIdsToNames = {};
    const dataWithIds = Object.keys(data).map((key, index) => {
        mappingOfLaneIdsToNames[index] = key;
        const thePoints = data[key].points;
        const pointsWithId = thePoints.map(point => {
            return {
                ...point,
                laneID: index,
            };
        });
        return {
            points: pointsWithId,
            shape: data[key].shape,
            color: data[key].color,
            laneID: index,
        };
    });
    const formatIdsToNames = (value) => {
        return React.createElement("span", null, mappingOfLaneIdsToNames[value]);
    };
    // TODO: Allow for proper styling and make things less hacky than "payload[0]"
    const defaultFormatTooltip = ({ active, payload }) => {
        if (active) {
            return (React.createElement("div", { style: {
                    backgroundColor: stylingProps === null || stylingProps === void 0 ? void 0 : stylingProps.tooltipBackgroundColor,
                    color: stylingProps === null || stylingProps === void 0 ? void 0 : stylingProps.tooltipTextColor,
                } }, localTimeFormatter(payload[0].value)));
        }
        return null;
    };
    return (React.createElement(ResponsiveContainer, { width: "100%", height: "100%" },
        React.createElement(ScatterChart, null,
            React.createElement(CartesianGrid, { fill: (_a = stylingProps === null || stylingProps === void 0 ? void 0 : stylingProps.gridBackgroundColor) !== null && _a !== void 0 ? _a : "black", stroke: (_b = stylingProps === null || stylingProps === void 0 ? void 0 : stylingProps.gridStroke) !== null && _b !== void 0 ? _b : "white" }),
            React.createElement(XAxis, { dataKey: xAxisDataKey, type: "number", domain: [xAxisDomainMin, xAxisDomainMax], tickFormatter: tickFormatterFunc, allowDataOverflow: true, ticks: regularIntervalTicks ? ticks : null, stroke: stylingProps === null || stylingProps === void 0 ? void 0 : stylingProps.xAxisStroke }),
            React.createElement(YAxis, { dataKey: "laneID", type: "number", padding: { bottom: 30, top: 30 }, hide: true }),
            React.createElement(Tooltip, { content: tooltipFormatterFunc !== null && tooltipFormatterFunc !== void 0 ? tooltipFormatterFunc : defaultFormatTooltip }),
            legend ? React.createElement(Legend, { iconSize: 18, formatter: formatIdsToNames }) : null,
            Object.keys(dataWithIds).map(lane => {
                var _a, _b, _c;
                const { points } = dataWithIds[lane];
                return (React.createElement(Scatter, { key: lane, data: points, name: lane, shape: (_a = dataWithIds[lane].shape) !== null && _a !== void 0 ? _a : "circle", fill: (_b = dataWithIds[lane].color) !== null && _b !== void 0 ? _b : "null", legendType: (_c = dataWithIds[lane].shape) !== null && _c !== void 0 ? _c : "circle" }));
            }))));
};
export default LinearTimeline;
