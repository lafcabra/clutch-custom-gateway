import React from "react";
import { CartesianGrid, Legend, Line, LineChart, ReferenceLine, ResponsiveContainer, Tooltip, XAxis, YAxis, } from "recharts";
import { calculateDomainEdges, calculateTicks, localTimeFormatter } from "./helpers";
/*
  For the lines, use the `dataKey` property to denote which data points belong to that line. Make sure that
  all the dataKeys match appropriately (the XAxis datakey should correspond to the data that is graphed along
  the XAxis, and same for Y. Note that we currently set the XAxis to be a time scale, hence the name
  Timeseries Chart).
  
  The data will be internally sorted by the XAxis dataKey when using single line mode. When having multiple lines
  (singleLineMode is false) then the user is responsible for sorting and grouping the data appropriately.
  If they do not sort and group it, there can be discontinuities in the lines. Also, when using multiple lines,
  the user should pass the yAxisDataKey as the biggest ranged y axis datakey in the data, otherwise data will get chopped off.

  The timestamps are interpreted as unix milliseconds.
*/
// TODO(smonero): add tests for this component
const TimeseriesChart = ({ data, xAxisDataKey = "timestamp", yAxisDataKey = "value", lines, refLines, singleLineMode = true, drawDots = true, legend = true, grid = true, tickFormatterFunc = localTimeFormatter, xDomainSpread = 0.2, yDomainSpread = 0.2, connectNulls = false, regularIntervalTicks = false, tooltipFormatterFunc = null, stylingProps = {}, }) => {
    if (singleLineMode) {
        data.sort((a, b) => a[xAxisDataKey] - b[xAxisDataKey]);
    }
    const [yAxisDomainMin, yAxisDomainMax] = calculateDomainEdges(data, yAxisDataKey, yDomainSpread !== null && yDomainSpread !== void 0 ? yDomainSpread : 0);
    const [xAxisDomainMin, xAxisDomainMax] = calculateDomainEdges(data, xAxisDataKey, xDomainSpread !== null && xDomainSpread !== void 0 ? xDomainSpread : 0);
    // In the spirit of making a friendly UX, there is an option to generate evenly spaced, round-timestamped, ticks.
    // Depending on the distance between the max and min timestamps, we calculate a set of ticks at certain intervals
    // (I.e. if there are several minutes, we might use minute intervals, whereas if there are only a few minutes range,
    // we would use 30 second intervals, and if the range consists of hours, we might use 15 or 30 minute intervals)
    let ticks = [];
    if (regularIntervalTicks) {
        ticks = calculateTicks(data, xAxisDataKey);
    }
    return (React.createElement(ResponsiveContainer, { width: "100%", height: "100%" },
        React.createElement(LineChart, { data: data },
            grid ? (React.createElement(CartesianGrid, { stroke: stylingProps === null || stylingProps === void 0 ? void 0 : stylingProps.gridStroke, fill: stylingProps === null || stylingProps === void 0 ? void 0 : stylingProps.gridBackgroundColor })) : null,
            React.createElement(XAxis, { dataKey: xAxisDataKey, type: "number", domain: [xAxisDomainMin, xAxisDomainMax], tickFormatter: tickFormatterFunc, allowDataOverflow: true, ticks: regularIntervalTicks ? ticks : null, stroke: stylingProps === null || stylingProps === void 0 ? void 0 : stylingProps.xAxisStroke }),
            // Note that if a number is NaN Recharts will default the domain to `auto`
            singleLineMode ? (React.createElement(YAxis, { dataKey: yAxisDataKey, domain: [yAxisDomainMin, yAxisDomainMax], stroke: stylingProps === null || stylingProps === void 0 ? void 0 : stylingProps.yAxisStroke, type: "number" })) : (React.createElement(YAxis, { type: "number", domain: [yAxisDomainMin, yAxisDomainMax], stroke: stylingProps === null || stylingProps === void 0 ? void 0 : stylingProps.yAxisStroke })),
            React.createElement(Tooltip, { formatter: tooltipFormatterFunc }),
            legend ? React.createElement(Legend, null) : null,
            lines
                ? lines.map((line, index) => {
                    var _a;
                    return (React.createElement(Line, { key: index.toString() + line.dataKey, type: "linear", dataKey: line.dataKey, stroke: line.color, animationDuration: (_a = line.animationDuration) !== null && _a !== void 0 ? _a : 0, dot: drawDots, connectNulls: connectNulls }));
                })
                : null,
            refLines &&
                refLines.map((refLine, index) => {
                    const props = {};
                    props[refLine.axis] = refLine.coordinate;
                    return (React.createElement(ReferenceLine, Object.assign({ key: index.toString() + refLine.coordinate.toString(), label: refLine.label, stroke: refLine.color, strokeDasharray: refLine.axis === "x" ? "3 3" : "4 4" }, props)));
                }))));
};
export default TimeseriesChart;
