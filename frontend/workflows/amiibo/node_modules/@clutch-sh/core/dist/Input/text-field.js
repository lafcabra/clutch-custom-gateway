import * as React from "react";
import styled from "@emotion/styled";
import { Grid, IconButton as MuiIconButton, Popper as MuiPopper, TextField as MuiTextField, Typography, } from "@material-ui/core";
import ErrorIcon from "@material-ui/icons/Error";
import Autocomplete from "@material-ui/lab/Autocomplete";
import _ from "lodash";
const KEY_ENTER = 13;
const BaseTextField = ({ InputProps, InputLabelProps, ...props }) => (React.createElement(MuiTextField, Object.assign({ InputLabelProps: { ...InputLabelProps, shrink: true }, InputProps: { ...InputProps, disableUnderline: true }, fullWidth: true }, props)));
const StyledTextField = styled(BaseTextField)({
    ".MuiInputLabel-root": {
        fontSize: "14px",
        fontWeight: 500,
        transform: "scale(1)",
        marginLeft: "2px",
    },
    ".MuiInputLabel-root, .MuiInputLabel-root.Mui-focused": {
        color: "rgba(13, 16, 48, 0.6)",
    },
    ".MuiInputLabel-root.Mui-disabled": {
        color: "rgba(13, 16, 48, 0.38)",
    },
    ".MuiInputLabel-root.Mui-error": {
        color: "#db3615",
    },
    ".MuiInputBase-root": {
        border: "1px solid rgba(13, 16, 48, 0.38)",
        borderRadius: "4px",
        fontSize: "16px",
        color: "#0D1030",
        backgroundColor: "#FFFFFF",
    },
    "label + .MuiInput-formControl": {
        marginTop: "20px",
    },
    ".MuiInputBase-root.Mui-focused": {
        borderColor: "#3548d4",
    },
    ".MuiInputBase-root.Mui-disabled": {
        backgroundColor: "rgba(13, 16, 48, 0.12)",
    },
    ".MuiInput-input": {
        padding: "14px 16px",
        height: "20px",
    },
    ".MuiInput-input::placeholder": {
        color: "rgba(13, 16, 48, 0.38)",
        opacity: 1,
    },
    ".MuiFormHelperText-root": {
        alignItems: "center",
        display: "flex",
        position: "relative",
        fontSize: "12px",
        marginTop: "7px",
        lineHeight: "16px",
    },
    ".MuiFormHelperText-root.Mui-error": {
        color: "#db3615",
    },
    ".MuiInputBase-root.Mui-error": {
        borderColor: "#db3615",
    },
    ".MuiFormHelperText-root > svg": {
        height: "16px",
        width: "16px",
        marginRight: "4px",
    },
});
// popper containing the search result options
const Popper = styled(MuiPopper)({
    ".MuiAutocomplete-paper": {
        boxShadow: "0px 5px 15px rgba(53, 72, 212, 0.2)",
    },
    ".MuiAutocomplete-option": {
        height: "48px",
        padding: "0px",
    },
    ".MuiAutocomplete-option[data-focus='true']": {
        background: "#ebedfb",
    },
    ".MuiAutocomplete-noOptions": {
        fontSize: "14px",
        color: "#0d1030",
    },
});
// search's result options container
const ResultGrid = styled(Grid)({
    height: "inherit",
    padding: "12px 16px 12px 16px",
});
// search's result options
const ResultLabel = styled(Typography)({
    color: "#0d1030",
    fontSize: "14px",
});
const IconButton = styled(MuiIconButton)({
    borderRadius: "0",
    backgroundColor: "#3548D4",
    color: "#FFFFFF",
    borderBottomRightRadius: "3px",
    borderTopRightRadius: "3px",
    "&:hover": {
        backgroundColor: "#2D3DB4",
    },
    "&:active": {
        backgroundColor: "#2938A5",
    },
});
const AutocompleteResult = ({ id, label }) => (React.createElement(ResultGrid, { container: true, alignItems: "center" },
    React.createElement(Grid, { item: true, xs: true },
        React.createElement(ResultLabel, null, id))));
const TextField = ({ onChange, onReturn, error, helperText, readOnly, endAdornment, autocompleteCallback, defaultValue, value, fullWidth = true, name, required, formRegistration, inputRef, ...props }) => {
    const formValidation = formRegistration !== undefined ? formRegistration(name, { required }) : undefined;
    const changeCallback = onChange !== undefined ? onChange : e => { };
    const onKeyDown = (e) => {
        if (formValidation !== undefined) {
            formValidation.onChange(e);
        }
        changeCallback(e);
        if (e.keyCode === KEY_ENTER && onReturn && !error) {
            onReturn();
        }
    };
    let helpText = helperText;
    // Prepend a '!' icon to helperText displayed below the form if the form is in an error state.
    if (error) {
        helpText = (React.createElement(React.Fragment, null,
            React.createElement(ErrorIcon, null),
            helperText));
    }
    // We maintain a defaultVal to prevent the value from changing from underneath
    // the component. This is required because autocomplete is uncontrolled.
    const [defaultVal] = React.useState(defaultValue || "");
    const [autoCompleteOptions, setAutoCompleteOptions] = React.useState([]);
    const isEmpty = (defaultValue === undefined || defaultValue === "") && value === "";
    const textFieldProps = {
        name,
        onFocus: e => {
            if (formValidation !== undefined) {
                formValidation.onChange(e);
            }
            changeCallback(e);
        },
        onBlur: e => {
            if (formValidation !== undefined) {
                formValidation.onBlur(e);
            }
            changeCallback(e);
        },
        error,
        helperText: helpText,
        InputProps: {
            onChange: e => {
                if (formValidation !== undefined) {
                    formValidation.onChange(e);
                }
                changeCallback(e);
            },
            onKeyDown,
            readOnly,
            endAdornment: endAdornment && (React.createElement(IconButton, { type: "submit", disabled: isEmpty }, endAdornment)),
        },
        inputRef: formValidation !== undefined ? formValidation.ref : inputRef,
    };
    const autoCompleteDebounce = React.useRef(_.debounce(val => {
        if (autocompleteCallback !== undefined) {
            autocompleteCallback(val)
                .then(data => {
                setAutoCompleteOptions(data.results);
            })
                .catch(err => {
                helpText = err;
            });
        }
    }, 250)).current;
    if (autocompleteCallback !== undefined) {
        // TODO (mcutalo): support option.label in the renderOption
        return (React.createElement(Autocomplete, { freeSolo: true, size: "small", fullWidth: fullWidth, options: autoCompleteOptions, PopperComponent: Popper, getOptionLabel: (option) => typeof option === "string" ? option : (option === null || option === void 0 ? void 0 : option.id) || option.label, onInputChange: (__, v) => autoCompleteDebounce(v), renderOption: (option) => (React.createElement(AutocompleteResult, { id: option.id, label: option.label })), onSelectCapture: e => {
                if (formValidation !== undefined) {
                    formValidation.onChange(e);
                }
                changeCallback(e);
            }, defaultValue: { id: defaultVal, label: defaultVal }, value: value, renderInput: inputProps => (React.createElement(StyledTextField, Object.assign({}, inputProps, textFieldProps, { InputProps: {
                    ...textFieldProps.InputProps,
                    ref: inputProps.InputProps.ref,
                } }, props))), 
            // This func is here for autocomplete. When the user clicks a choice in the dropdown
            // or presses enter, onChange is called, which will allow the user to submit their choice.
            // Without this, the user has to click their choice or press enter, then submit again once
            // the choice has updated. Note that this does not work if the `value` prop is being set
            // manually (as is the case in proj selector and proj catalog)
            // TODO: Make it work for all cases, not just the resolver and k8s dash.
            onChange: (_e, v) => {
                if (v && onReturn) {
                    onReturn();
                }
            } }));
    }
    return (React.createElement(StyledTextField, Object.assign({}, textFieldProps, { defaultValue: defaultValue, value: value, onChange: onChange }, props)));
};
export default TextField;
