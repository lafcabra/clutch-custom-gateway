import axios from "axios";
import { grpcResponseToError } from "./errors";
const successInterceptor = (response) => {
    return response;
};
const errorInterceptor = (error) => {
    var _a, _b;
    const response = error === null || error === void 0 ? void 0 : error.response;
    if (response === undefined) {
        const clientError = {
            status: {
                code: 500,
                text: "Client Error",
            },
            message: error.message,
        };
        return Promise.reject(clientError);
    }
    // This section handles authentication redirects.
    if ((response === null || response === void 0 ? void 0 : response.status) === 401) {
        // TODO: turn this in to silent refresh once refresh tokens are supported.
        const redirectUrl = window.location.pathname + window.location.search;
        window.location.href = `/v1/authn/login?redirect_url=${encodeURIComponent(redirectUrl)}`;
    }
    // we are guaranteed to have a response object on the error from this point on
    // since we have already accounted for axios errors.
    const responseData = (_a = error === null || error === void 0 ? void 0 : error.response) === null || _a === void 0 ? void 0 : _a.data;
    // if the response data has a code on it we know it's a gRPC response.
    let err;
    if ((responseData === null || responseData === void 0 ? void 0 : responseData.code) !== undefined) {
        err = grpcResponseToError(error);
    }
    else {
        const message = typeof ((_b = error.response) === null || _b === void 0 ? void 0 : _b.data) === "string"
            ? error.response.data
            : (error === null || error === void 0 ? void 0 : error.message) || error.response.statusText;
        err = {
            status: {
                code: error.response.status,
                text: error.response.statusText,
            },
            message,
            data: responseData,
        };
    }
    return Promise.reject(err);
};
const createClient = () => {
    const axiosClient = axios.create({
        // n.b. the client will treat any response code >= 400 as an error and apply the error interceptor.
        validateStatus: status => {
            return status < 400;
        },
    });
    axiosClient.interceptors.response.use(successInterceptor, errorInterceptor);
    return axiosClient;
};
const client = createClient();
export { client, errorInterceptor, successInterceptor };
