import React from "react";
import styled from "@emotion/styled";
import _ from "lodash";
import { AccordionGroup } from "../accordion";
import { useWizardContext } from "../Contexts";
import { Error, NotePanel } from "../Feedback";
import { HorizontalRule } from "../horizontal-rule";
import Loadable from "../loading";
import { useSearchParams } from "../navigation";
import { fetchResourceSchemas, resolveResource } from "./fetch";
import { QueryResolver, SchemaResolver } from "./input";
import { ResolverAction, useResolverState } from "./state";
const SchemaLabel = styled.div({
    alignSelf: "flex-start",
    fontSize: "20px",
    fontWeight: 700,
    marginBottom: "8px",
});
const loadSchemas = (type, dispatch) => {
    fetchResourceSchemas(type)
        .then(schemas => {
        if (schemas.length === 0) {
            dispatch({
                type: ResolverAction.SCHEMAS_ERROR,
                error: {
                    message: `No schemas found for type '${type}'`,
                    status: {
                        code: 404,
                        text: "Not Found",
                    },
                },
            });
        }
        else {
            dispatch({ type: ResolverAction.SCHEMAS_SUCCCESS, allSchemas: schemas });
        }
    })
        .catch(err => {
        dispatch({ type: ResolverAction.SCHEMAS_ERROR, error: err });
    });
};
const Resolver = ({ type, searchLimit, onResolve, variant = "dual", apiPackage, enableAutocomplete = true, notes = [], }) => {
    const [state, dispatch] = useResolverState();
    const { displayWarnings } = useWizardContext();
    React.useEffect(() => loadSchemas(type, dispatch), []);
    const submitHandler = data => {
        // Move to loading state.
        dispatch({ type: ResolverAction.RESOLVING });
        // Copy incoming data, trimming whitespace from any string values (usually artifact of cut and paste into tool).
        const inputData = _.mapValues(data, v => (_.isString(v) && _.trim(v)) || v);
        // Resolve!
        resolveResource(type, searchLimit, inputData, (results, partialFailures) => {
            onResolve({ results, input: inputData });
            if (!_.isEmpty(partialFailures)) {
                displayWarnings(partialFailures);
            }
            dispatch({ type: ResolverAction.RESOLVE_SUCCESS });
        }, err => dispatch({ type: ResolverAction.RESOLVE_ERROR, error: err }), apiPackage);
    };
    const [searchParams, setSearchParams] = useSearchParams();
    React.useEffect(() => {
        if (searchParams.get("q")) {
            submitHandler({ query: searchParams.get("q") });
        }
    }, []);
    return (React.createElement(Loadable, { isLoading: state.schemasLoading }, state.schemaFetchError ? (React.createElement(Error, { subject: state.schemaFetchError, onRetry: () => loadSchemas(type, dispatch) })) : (React.createElement(Loadable, { variant: "overlay", isLoading: state.resolverLoading },
        state.resolverFetchError && React.createElement(Error, { subject: state.resolverFetchError }),
        React.createElement(NotePanel, { notes: notes }),
        (variant === "dual" || variant === "query") && (React.createElement(React.Fragment, null,
            React.createElement(SchemaLabel, null, "Search"),
            React.createElement(QueryResolver, { inputType: type, schemas: state.searchableSchemas, submitHandler: data => {
                    setSearchParams({ q: data.query });
                    submitHandler(data);
                }, enableAutocomplete: enableAutocomplete }))),
        variant === "dual" && React.createElement(HorizontalRule, null, "OR"),
        React.createElement(SchemaLabel, null, "Advanced Search"),
        React.createElement(AccordionGroup, { defaultExpandedIdx: 0 }, state.allSchemas.map(schema => (React.createElement(SchemaResolver, { key: schema.typeUrl, schema: schema, submitHandler: submitHandler }))))))));
};
export default Resolver;
