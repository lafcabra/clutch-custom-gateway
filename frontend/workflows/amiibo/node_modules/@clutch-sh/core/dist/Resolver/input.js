import React from "react";
import { useForm } from "react-hook-form";
import styled from "@emotion/styled";
import { DevTool } from "@hookform/devtools";
import SearchIcon from "@material-ui/icons/Search";
import { Accordion, AccordionActions, AccordionDetails, AccordionDivider, } from "../accordion";
import { Button } from "../button";
import { Alert } from "../Feedback";
import TextField from "../Input/text-field";
import { useSearchParams } from "../navigation";
import { client } from "../Network";
import { convertChangeEvent, hydrateField } from "./hydrator";
const Form = styled.form({});
const autoComplete = async (type, search) => {
    var _a;
    // Check the length of the search query as the user might empty out the search
    // which will still trigger the on change handler
    if (search.length === 0) {
        return { results: [] };
    }
    const response = await client.post("/v1/resolver/autocomplete", {
        want: `type.googleapis.com/${type}`,
        search,
    });
    return { results: ((_a = response === null || response === void 0 ? void 0 : response.data) === null || _a === void 0 ? void 0 : _a.results) || [] };
};
const QueryResolver = ({ inputType, schemas, submitHandler, enableAutocomplete = true, }) => {
    var _a;
    const validation = useForm({
        mode: "onSubmit",
        reValidateMode: "onSubmit",
        shouldFocusError: false,
    });
    const [searchParams] = useSearchParams();
    const [queryData, setQueryData] = React.useState(searchParams.get("q") || "");
    let typeLabel = schemas.map(schema => schema === null || schema === void 0 ? void 0 : schema.metadata.displayName).join();
    typeLabel = `Search by ${typeLabel}`;
    const handleChanges = (event) => {
        setQueryData(convertChangeEvent(event).target.value);
    };
    // If there is at least 1 schema that has the ability to autocomplete we will enable it.
    // enableAutocomplete's default value is true.  We only use it (set it to false) when we want to override and disable autocomplete at the workflow level rather than the schema level.
    const isAutoCompleteEnabled = schemas.filter(schema => { var _a, _b; return ((_b = (_a = schema === null || schema === void 0 ? void 0 : schema.metadata) === null || _a === void 0 ? void 0 : _a.search) === null || _b === void 0 ? void 0 : _b.autocompleteEnabled) === true; }).length >= 1 &&
        enableAutocomplete;
    const error = (_a = validation.formState.errors) === null || _a === void 0 ? void 0 : _a.query;
    return (React.createElement(Form, { onSubmit: validation.handleSubmit(() => submitHandler({ query: queryData })), noValidate: true },
        process.env.REACT_APP_DEBUG_FORMS && React.createElement(DevTool, { control: validation.control }),
        React.createElement(TextField, { label: typeLabel, name: "query", required: true, defaultValue: queryData, onChange: handleChanges, onKeyDown: handleChanges, onFocus: handleChanges, error: !!error, helperText: (error === null || error === void 0 ? void 0 : error.message) || (error === null || error === void 0 ? void 0 : error.type) || "", endAdornment: React.createElement(SearchIcon, null), autocompleteCallback: isAutoCompleteEnabled ? v => autoComplete(inputType, v) : undefined, formRegistration: validation.register })));
};
const SchemaDetails = styled(AccordionDetails)({
    "> *": {
        flex: "1 50%",
    },
});
const SchemaResolver = ({ schema, expanded, onClick, submitHandler }) => {
    const [data, setData] = React.useState({ "@type": schema.typeUrl });
    const schemaValidation = useForm({
        mode: "onSubmit",
        reValidateMode: "onSubmit",
        shouldFocusError: false,
    });
    const onChange = e => {
        setData(existing => {
            return { ...existing, [e.target.name]: e.target.value };
        });
    };
    return (React.createElement(Form, { noValidate: true, onSubmit: schemaValidation.handleSubmit(() => submitHandler(data)) },
        React.createElement(Accordion, { title: `Search by ${schema.metadata.displayName}`, expanded: expanded, onClick: onClick },
            React.createElement(SchemaDetails, null, schema.error ? (React.createElement(Alert, { severity: "error" },
                "Schema Error: $",
                schema.error.message)) : (schema.fields.map(field => hydrateField(field, onChange, schemaValidation)))),
            React.createElement(AccordionDivider, null),
            React.createElement(AccordionActions, null,
                React.createElement(Button, { text: "Submit", type: "submit" })))));
};
export { SchemaResolver, QueryResolver };
