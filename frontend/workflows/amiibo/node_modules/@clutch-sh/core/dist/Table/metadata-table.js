import * as React from "react";
import { useForm } from "react-hook-form";
import { DevTool } from "@hookform/devtools";
import { yupResolver } from "@hookform/resolvers/yup";
import { Grid as MuiGrid, Table as MuiTable, TableBody as MuiTableBody, TableCell as MuiTableCell, TableContainer as MuiTableContainer, TableRow, } from "@material-ui/core";
import ChevronRightIcon from "@material-ui/icons/ChevronRight";
import _ from "lodash";
import { object } from "yup";
import { useWizardContext } from "../Contexts";
import TextField from "../Input/text-field";
import styled from "../styled";
const TableContainer = styled(MuiTableContainer)({
    borderWidth: "0",
    border: "0",
}, props => ({
    maxHeight: props.$maxHeight || "fit-content",
}));
const Table = styled(MuiTable)({
    border: "1px solid rgba(13, 16, 48, 0.12)",
    borderRadius: "4px",
    borderCollapse: "unset",
});
const TableBody = styled(MuiTableBody)({
    "tr:first-of-type > td:first-of-type": {
        borderTopLeftRadius: "3px",
    },
    "tr:first-of-type > td:last-of-type": {
        borderTopRightRadius: "3px",
    },
    "tr:last-of-type > td": {
        borderBottom: "0",
    },
    "tr:last-of-type > td:first-of-type": {
        borderBottomLeftRadius: "3px",
    },
    "tr:last-of-type > td:last-of-type": {
        borderBottomRightRadius: "3px",
    },
});
const TableCell = styled(MuiTableCell)({
    color: "#0D1030",
    fontSize: "14px",
    fontWeight: "normal",
    height: "48px",
    padding: "0 16px",
});
const Grid = styled(MuiGrid)({
    display: "flex",
    alignItems: "center",
    ".MuiFormControl-root": {
        flexDirection: "row",
    },
    ".MuiFormControl-root .MuiInputBase-root": {
        height: "40px",
        width: "100px",
        alignSelf: "center",
    },
    ".MuiFormControl-root .MuiFormHelperText-root.Mui-error": {
        flex: 1,
    },
    ".textfield-disabled .MuiFormControl-root .MuiInputBase-root": {
        width: "41px",
    },
    ".textfield-disabled .MuiInput-input": {
        padding: "0px",
        textAlign: "center",
    },
});
const KeyCellContainer = styled(TableCell)({
    width: "45%",
    background: "rgba(13, 16, 48, 0.03)",
    fontWeight: 500,
});
const KeyCell = ({ data }) => {
    let { name } = data;
    if (data.value instanceof Array && data.value.length > 1) {
        name = `${data.name}s`;
    }
    return React.createElement(KeyCellContainer, null, name);
};
const ImmutableRow = ({ data }) => {
    let { value } = data;
    if (data.value instanceof Array && data.value.length > 1) {
        value = data.value.join(", ");
    }
    return (React.createElement(TableRow, { key: data.id },
        React.createElement(KeyCell, { data: data }),
        React.createElement(TableCell, null, value)));
};
const MutableRow = ({ data, onUpdate, onReturn, validation }) => {
    var _a, _b, _c;
    const error = (_b = (_a = validation === null || validation === void 0 ? void 0 : validation.formState) === null || _a === void 0 ? void 0 : _a.errors) === null || _b === void 0 ? void 0 : _b[data.name];
    // intercept the update callback to prevent updates if there are form errors present
    // based on the validation.
    const updateCallback = (e) => error ? () => { } : onUpdate(e);
    return (React.createElement(TableRow, { key: data.id },
        React.createElement(KeyCell, { data: data }),
        React.createElement(TableCell, null,
            React.createElement(Grid, null,
                React.createElement("div", { className: "textfield-disabled" },
                    React.createElement(TextField, { disabled: true, id: data.id, name: data.name, defaultValue: data.value })),
                React.createElement(ChevronRightIcon, null),
                React.createElement(TextField, { id: data.id, name: data.name, defaultValue: data.value, type: (_c = data === null || data === void 0 ? void 0 : data.input) === null || _c === void 0 ? void 0 : _c.type, onChange: updateCallback, onReturn: onReturn, onFocus: updateCallback, helperText: (error === null || error === void 0 ? void 0 : error.message) || "", error: !!error || false, formRegistration: validation.register })))));
};
export const MetadataTable = ({ data, onUpdate, maxHeight, children, }) => {
    const { onSubmit, setOnSubmit } = useWizardContext();
    let rows = data;
    if (_.isEmpty(data)) {
        rows = [{ name: "Error", value: "No Data Available" }];
    }
    else {
        rows = data.map(row => {
            var _a;
            const id = ((_a = row === null || row === void 0 ? void 0 : row.input) === null || _a === void 0 ? void 0 : _a.key) || _.camelCase(row.name);
            return { ...row, id };
        });
    }
    const validationShape = {};
    rows.forEach(row => {
        var _a;
        if ((_a = row === null || row === void 0 ? void 0 : row.input) === null || _a === void 0 ? void 0 : _a.validation) {
            validationShape[row.name] = row.input.validation;
        }
    });
    const validation = useForm({
        mode: "onChange",
        resolver: yupResolver(object().shape(validationShape)),
    });
    const { control, handleSubmit } = validation;
    React.useEffect(() => {
        setOnSubmit(handleSubmit);
    }, []);
    return (React.createElement(TableContainer, { "$maxHeight": maxHeight },
        process.env.REACT_APP_DEBUG_FORMS && onUpdate !== undefined && React.createElement(DevTool, { control: control }),
        React.createElement(Table, null,
            React.createElement(TableBody, null,
                rows.map((row) => {
                    return row.input !== undefined && onUpdate ? (React.createElement(MutableRow, { data: row, onUpdate: e => {
                            onUpdate(e.target.id, e.target.value);
                        }, onReturn: onSubmit, key: row.id, validation: validation })) : (React.createElement(ImmutableRow, { data: row, key: row.id }));
                }),
                children))));
};
export default MetadataTable;
