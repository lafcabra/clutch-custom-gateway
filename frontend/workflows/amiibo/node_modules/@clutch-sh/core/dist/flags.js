import * as React from "react";
import { client } from "./Network/index";
const FEATURE_FLAG_POLL_RATE = +process.env.REACT_APP_FF_POLL || 300000;
const FF_CACHE_TTL = +process.env.REACT_APP_FF_CACHE_TTL || 60000;
const featureFlags = () => {
    const cachedFlags = JSON.parse(sessionStorage.getItem("featureFlags"));
    if (cachedFlags) {
        const elapsedTime = new Date(new Date().getTime() - cachedFlags.timestamp).getTime();
        if (elapsedTime < FF_CACHE_TTL) {
            return new Promise(resolve => resolve(cachedFlags.flags));
        }
    }
    return client
        .post("/v1/featureflag/getFlags", {}, { timeout: 1000 })
        .then(response => {
        const { flags } = response.data;
        const cache = {
            timestamp: new Date().getTime(),
            flags,
        };
        sessionStorage.setItem("featureFlags", JSON.stringify(cache));
        return flags;
    })
        .catch((error) => {
        // TODO: add instrumentation here
        console.warn("failed to fetch flags: ", error); // eslint-disable-line
        return (cachedFlags === null || cachedFlags === void 0 ? void 0 : cachedFlags.flags) || {};
    });
};
/**
 * A generic simple feature flag component. This exists to mask the feature enabled
 * state as a prop on the exposed On/Off components.
 */
const GenericSimpleFeatureFlagState = ({ children, enabled, expectedState, }) => React.createElement(React.Fragment, null, enabled === expectedState && children);
const FeatureOn = ({ children }) => React.createElement(React.Fragment, null, children);
const FeatureOff = ({ children }) => React.createElement(React.Fragment, null, children);
/**
 * A feature flag wrapper that evaluates a binary value of a specified flag to determine
 * if it's children should be shown.
 */
const SimpleFeatureFlag = ({ feature, children }) => {
    const cachedFlags = JSON.parse(sessionStorage.getItem("featureFlags"));
    const [flags, setFlags] = React.useState((cachedFlags === null || cachedFlags === void 0 ? void 0 : cachedFlags.flags) || {});
    const [featureEnabled, setFeatureEnabled] = React.useState(false);
    const loadFlags = () => {
        featureFlags().then(f => setFlags(f));
    };
    React.useEffect(() => {
        loadFlags();
        const interval = setInterval(loadFlags, FEATURE_FLAG_POLL_RATE);
        return () => clearInterval(interval);
    }, []);
    React.useEffect(() => {
        const flag = flags === null || flags === void 0 ? void 0 : flags[feature];
        if (flag !== undefined) {
            setFeatureEnabled(flag.booleanValue);
        }
    }, [flags]);
    const statefulChildren = React.Children.map(children, child => (React.createElement(GenericSimpleFeatureFlagState, { enabled: featureEnabled, expectedState: child.type === FeatureOn }, child.props.children)));
    return React.createElement(React.Fragment, null, statefulChildren);
};
export { FEATURE_FLAG_POLL_RATE, featureFlags, FeatureOff, FeatureOn, SimpleFeatureFlag };
