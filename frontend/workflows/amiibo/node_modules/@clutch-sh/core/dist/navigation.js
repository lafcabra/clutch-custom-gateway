import { createSearchParams, useLocation, useNavigate as rrUseNavigate, useParams, useSearchParams as rrUseSearchParams, } from "react-router-dom";
const UTM_PARAMS = ["utm_source", "utm_medium"];
/**
 * Convert custom search param object to string.
 *
 * ```ts
 * const searchObject = new URLSearchParams({ query: "value" });
 * const searchString = convertSearchParam(searchObject);
 * console.log(searchString); // "?query=value"
 * ```
 */
const convertSearchParam = (params) => {
    const p = params.toString();
    if (p.indexOf("=") < 0) {
        return "";
    }
    return `?${p}`;
};
/**
 * Returns an imperative method for changing the location.
 *
 * This method wraps useNavigate from react-router but has custom
 * logic that:
 *   * Automatically preserves UTM parameters during navigation
 *   * Easily preserves the origin of navigation in state
 *   * Provides an easy interface to specify search parameters
 *
 * @see https://reactrouter.com/api/useNavigate for more information.
 */
const useNavigate = () => {
    const navigation = rrUseNavigate();
    const [currentSearchParams] = rrUseSearchParams();
    const customNavigate = (to, options = {}) => {
        var _a;
        const finalNavOptions = {};
        if (options === null || options === void 0 ? void 0 : options.replace) {
            finalNavOptions.replace = options.replace;
        }
        if (options === null || options === void 0 ? void 0 : options.state) {
            finalNavOptions.state = options.state;
        }
        let newSearchParams = {};
        if (typeof to !== "string") {
            newSearchParams = ((to === null || to === void 0 ? void 0 : to.search) || {});
        }
        const searchParams = createSearchParams(newSearchParams);
        if ((options === null || options === void 0 ? void 0 : options.utm) || (options === null || options === void 0 ? void 0 : options.utm) === undefined) {
            UTM_PARAMS.forEach(p => {
                const param = currentSearchParams.get(p);
                if (param && !searchParams.get(p)) {
                    searchParams.set(p, param);
                }
            });
        }
        if (options === null || options === void 0 ? void 0 : options.origin) {
            const origin = `${window.location.pathname}${window.location.search}`;
            // n.b. if origin is specified in the options don't overwrite it.
            // @ts-ignore
            if (!((_a = options.state) === null || _a === void 0 ? void 0 : _a.origin)) {
                // @ts-ignore
                finalNavOptions.state = { ...finalNavOptions.state, origin };
            }
        }
        let navPath = {};
        if (typeof to === "string") {
            navPath.pathname = to;
        }
        else {
            navPath = { pathname: to === null || to === void 0 ? void 0 : to.pathname, hash: to === null || to === void 0 ? void 0 : to.hash };
        }
        const [path, search] = navPath.pathname.split("?");
        navPath.pathname = path;
        if (search) {
            new URLSearchParams(search).forEach((v, k) => {
                searchParams.set(k, v);
            });
        }
        navPath.search = convertSearchParam(searchParams);
        navigation(navPath, finalNavOptions);
    };
    return customNavigate;
};
/**
 * A convienence wrapper for reading and writing search parameters via the
 * URLSearchParams interface. This custom hook wraps react-routers implementation
 * but changes the function to write search parameters to preserve UTM parameters
 * by default.
 */
const useSearchParams = () => {
    const [searchParams, setSearchParams] = rrUseSearchParams();
    const customSetSearchParams = (params, options) => {
        const newSearchParams = params;
        const reactRouterOptions = {};
        if (options === null || options === void 0 ? void 0 : options.replace) {
            reactRouterOptions.replace = options.replace;
        }
        if (options === null || options === void 0 ? void 0 : options.state) {
            reactRouterOptions.state = options.state;
        }
        if ((options === null || options === void 0 ? void 0 : options.utm) || (options === null || options === void 0 ? void 0 : options.utm) === undefined) {
            UTM_PARAMS.forEach(p => {
                const param = searchParams.get(p);
                if (param && !newSearchParams[p]) {
                    newSearchParams[p] = param;
                }
            });
        }
        setSearchParams(newSearchParams, reactRouterOptions);
    };
    return [searchParams, customSetSearchParams];
};
export { convertSearchParam, useLocation, useParams, useSearchParams, useNavigate };
