import React from "react";
import { Button, ButtonGroup, FeatureOn, NPSWizard, SimpleFeatureFlag, Step, Stepper, styled, useLocation, useNavigate, useSearchParams, Warning, WizardContext, } from "@clutch-sh/core";
import { DataLayoutContext, useDataLayoutManager } from "@clutch-sh/data-layout";
import { Container as MuiContainer, Grid, Paper as MuiPaper, Typography } from "@material-ui/core";
import { useWizardState, WizardAction } from "./state";
const Heading = styled(Typography)({
    paddingBottom: "16px",
    fontWeight: 700,
    fontSize: "26px",
});
const Container = styled(MuiContainer)({
    padding: "32px",
    maxWidth: "unset",
}, props => ({
    width: props.$width === "full" ? "100%" : "800px",
}));
const Paper = styled(MuiPaper)({
    boxShadow: "0px 5px 15px rgba(53, 72, 212, 0.2)",
    padding: "32px",
});
const Wizard = ({ heading, width = "default", dataLayout, children }) => {
    const [state, dispatch] = useWizardState();
    const [wizardStepData, setWizardStepData] = React.useState({});
    const [globalWarnings, setGlobalWarnings] = React.useState([]);
    const dataLayoutManager = useDataLayoutManager(dataLayout);
    const [, setSearchParams] = useSearchParams();
    const locationState = useLocation().state;
    const navigate = useNavigate();
    const [origin] = React.useState(locationState === null || locationState === void 0 ? void 0 : locationState.origin);
    const updateStepData = (stepName, data) => {
        setWizardStepData(prevState => {
            const updatedData = {
                ...((prevState === null || prevState === void 0 ? void 0 : prevState[stepName]) || {}),
                ...data,
            };
            const stepData = { [stepName]: updatedData };
            return { ...prevState, ...stepData };
        });
    };
    const handleNext = () => {
        dispatch(WizardAction.NEXT);
    };
    const context = (child) => {
        var _a;
        return {
            onSubmit: ((_a = wizardStepData === null || wizardStepData === void 0 ? void 0 : wizardStepData[child.type.name]) === null || _a === void 0 ? void 0 : _a.onSubmit) || handleNext,
            setOnSubmit: (f) => {
                updateStepData(child.type.name, { onSubmit: f(handleNext) });
            },
            setIsLoading: (isLoading) => {
                updateStepData(child.type.name, { isLoading });
            },
            setHasError: (hasError) => {
                updateStepData(child.type.name, { hasError });
            },
            displayWarnings: (warnings) => {
                setGlobalWarnings(warnings);
            },
            onBack: (params) => {
                setGlobalWarnings([]);
                setSearchParams({});
                if ((params === null || params === void 0 ? void 0 : params.toOrigin) && origin) {
                    navigate(origin);
                }
                else {
                    dispatch(WizardAction.BACK);
                }
            },
        };
    };
    // toArray will exclude any null Children.
    const filteredChildren = React.Children.toArray(children);
    const lastStepIndex = filteredChildren.length - 1;
    // If our wizard only has 1 step, it doesn't make sense to put a restart button
    const isMultistep = lastStepIndex > 0;
    const steps = filteredChildren.map((child) => {
        var _a, _b;
        const isLoading = ((_a = wizardStepData[child.type.name]) === null || _a === void 0 ? void 0 : _a.isLoading) || false;
        const hasError = (_b = wizardStepData[child.type.name]) === null || _b === void 0 ? void 0 : _b.hasError;
        return (React.createElement(React.Fragment, null,
            React.createElement(DataLayoutContext.Provider, { value: dataLayoutManager },
                React.createElement(WizardContext.Provider, { value: () => context(child) },
                    React.createElement(Grid, { container: true, direction: "column", justify: "center", alignItems: "center" }, child))),
            React.createElement(Grid, { container: true, justify: "center" }, ((state.activeStep === lastStepIndex && !isLoading) || hasError) && (React.createElement(React.Fragment, null,
                React.createElement(SimpleFeatureFlag, { feature: "npsWizard" },
                    React.createElement(FeatureOn, null,
                        React.createElement(NPSWizard, null))),
                (isMultistep || hasError) && (React.createElement(ButtonGroup, null,
                    React.createElement(Button, { text: "Start Over", onClick: () => {
                            dataLayoutManager.reset();
                            setSearchParams({});
                            dispatch(WizardAction.RESET);
                            if (origin) {
                                navigate(origin);
                            }
                        } }))))))));
    });
    const removeWarning = (warning) => {
        setGlobalWarnings(globalWarnings.filter(w => w !== warning));
    };
    return (React.createElement(Container, { "$width": width },
        React.createElement(Grid, { container: true, direction: "column", justify: "center", alignItems: "stretch", style: { display: "inline" } },
            heading && React.createElement(Heading, null, heading),
            React.createElement(Grid, { item: true },
                React.createElement(Stepper, { activeStep: state.activeStep }, filteredChildren.map((child) => {
                    var _a;
                    const { name } = child.props;
                    const hasError = (_a = wizardStepData[child.type.name]) === null || _a === void 0 ? void 0 : _a.hasError;
                    return React.createElement(Step, { key: name, label: name, error: hasError });
                })),
                React.createElement(Paper, { elevation: 0 }, steps[state.activeStep]))),
        globalWarnings.map(error => (React.createElement(Warning, { key: error, message: error, onClose: () => removeWarning(error) })))));
};
export default Wizard;
